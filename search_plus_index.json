{"./":{"url":"./","title":"博客简介","keywords":"","body":"我的知识库 本知识库主要用来记录编程、计算机网络、渗透测试等安全领域研究和学习的过程。 1、博客主要内容 主要包括以下几方面内容： 编程学习类: 包括汇编、c/C++、python、java等编程语言的学习笔记。 计算机基础知识类：该部分内容主要涉及计算机基础知识、概念、网络工程师、操作系统线管知识 安卓逆向：安卓安全领域相关内容，主要以看雪课程学习笔记为主 内网渗透：该部分内容主要侧重内网渗透中的手法，包括一些实战经验积累 web 安全方向：常见web漏洞的概念原理、Top10漏洞的学习过程 2、主要涉及的项目 按照上述主要内容。按照具体项目来组织博客，目前主要涉及以下： python 爬虫 安卓逆向课程 软件调试课程 计算机基础知识 内网渗透 恶意样本分析 ······· Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:12:25 "},"python/python语法基础.html":{"url":"python/python语法基础.html","title":"python语法基础","keywords":"","body":"1、使用request库构造请求 2、使用request构造请求 Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-10 17:06:26 "},"python/python构造网络请求.html":{"url":"python/python构造网络请求.html","title":"python构造网络请求","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-10 17:02:03 "},"python/python常用库.html":{"url":"python/python常用库.html","title":"python常用库","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-10 17:02:40 "},"计算机基础知识/总述.html":{"url":"计算机基础知识/总述.html","title":"计算机基础","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 21:03:13 "},"计算机基础知识/windows系统/Hook技术总结.html":{"url":"计算机基础知识/windows系统/Hook技术总结.html","title":"Hook技术总结","keywords":"","body":"1、Hook 的概述 Q: 什么是Hook？ A: 简单来说就是通过一定的手段埋下钩子,钩住我们关心的重要流程, 然后根据需要对执行过程进行干预。 Q: Hook用途是干什么？ A: 实现二次开发、补丁、信息截获、安全防护 Q: Hook技术的要点是什么？ A: 对于Hook来说如何选择Hook点事一个很重要的Point。 Q: x64平台Hook需要注意什么？ A: 基本方法与x86平台一致， 此外需要考虑： 指针的定义长度和操作问题、内存地址对齐问题、PE格式问题（某些结构体字段的差异等）、调用约定的变化（在x64中只有一种调用约定__fastcall）、指令跳转问题、PatchGuard问题（x64系统基本都开启了该功能，以确保内核的核心模块和重要数据结构不被随意修改，一旦被修改会产生CRITICAL_STRUCTURE_CORRUPTION的蓝屏错误）。 2、各种Hook的原理及其实现 2.1 Address Hook 基本原理 通过修改数据，通常是函数地址进行Hook。这些地址一般存放在各类表中、数据结构中、指定的地址、或者寄存器中。这些数据有一些特征：在某个时候通过影响EIP从而控制程序的流程。因此只要将改地址替换成Detours函数的地址就可以拿到程序的控制权了。 实现步骤 1、定义一个Detours函数：调用约定、参数、返回值员被Hook函数保持一致 2、定义一个与被Hook 函数原型一致的函数指针， 指向原始函数 3、遍历查表或遍历匹配替换原地址，关闭写保护以及写入Detours函数地址。 2.1.1 PE IAT 表 IAT(输入地址表)：在PE结构中，有一组数据结构，分别对应于被输入的DLL，每一个这样的结构都给出了被输入DLL的名称， 并指向一组函数指针， 称为导入地址表IAT， 其包含了每一个DLL中的函数地址。 特点： 只针对某个模块起作用。 2.1.2 PE的 EAT表 基本原理：PE文件的如数地址表（EAT）中存放的是函数地址的偏移，使用是需要加上模块基址。通过EAT Hook影响的是PE文件运行起来之后需要动态加载导入的函数（IAT Hook只能影响PE初始化时导入的函数， 不能影响通过LoadLibrary、GetProAddress调用的函数）。 2.1.3 user32.dll的回调函数表 基本原理：在user32.dll 中有一个名为USER32!apfnDispatch 的回调函数表，其中存放各种利用GUI的回调函数，通常与内核函数KeUserModeCallback函数配合使用。 2.1.4 IDT表 基本原理：IDT表（系统中断描述符表）中保存了系统中断对应的处理函数（包括调试中断、键盘、鼠标中断、系统调用中断等）。IDT表基址存放在idtr中，表内的项目数存放在idtl寄存器中。每个中断项的中断处理例程称为ISR。 2.1.5 SSDT表 windows应用程序调用API 后转入操作系统内核进行处理时首先用到SSDT表，是将R3的函数接口和R0的函数联系起来的一个映射表。 SSDT表：主要是处理来自 Ring3 层得 Kernel32.dll 中的系统调用。结构为KeServiceDescriptorTable， 在ntoskrnl.exe(Windows 操作系统内核文件，包括内核和执行体）是导出的，声明后直接使用。 Shadow SSDT 表：用于处理各种GUI服务的表，结构为KeServiceDescriptorTableShadow。为生命，通过其他方式访问。主要处理来自 User32.dll 和 GDI32.dll 中的系统调用。 2.1.6 C++类的虚函数表 基本原理： 函数重载和虚函数是C++很重要的一个功能，可以使子类以相同的接口实现与积累不同的功能。编译器试下这一功能时使用了虚函数表来保存虚函数的地址。默认情况下改地址保存了积累的虚函数地址，一旦子类冲在了某个函数，编译器就会用子类该函数地址替换虚函数表中对应的函数地址（在编译后虚函数表就是一个固定的表了）。可以通过修改虚函数地址表来进行Hook。 2.1.7 COM接口的功能函数 基本原理：COM 接口的所有接口函数都放在一个表中，与C++虚函数表一样。 2.2 Inline Hook Inline Hook是直接修改指令的Hook。一般使用：jmp、call、retn之类的转移指令。有以下五种模式。 2.2.1 jmp xxxxx(5字节) 直接跳转到某个地址。 2.2.2 push xxxxxx(6字节) 通过压栈返回实现跳转 2.2.3 mov eax, xxxxxxx/jmp eax (7字节) 先将转移地址放到寄存器中，再实现跳转。 EAX一般存放函数返回值，在函数入口修改不会影响函数的执行结果。 2.2.4 call Hook 修改call地址的Hook：直接将跳转地址改掉 替换Thunk方式的IAT Hook： 只修改函数偏移 2.2.5 HotPatch Hook 一个短调加一个长跳。 windows API开头指令两种形式: 有SEH、无SEH 每个函数的第一条指令一定为2字节，而且从函数位置往上一般是5个Nop或者一个INT3 2.3 基于异常的Hook 基本原理：当程序执行过程中发生异常时，系统内核的异常处理过程nt!kiDispatchexception会开始工作；在没有内核调试器存在且异常程序没被调试的情况下。系统会把异常处理过程转交给用户态的异常处理过程ntdll!RtDispatchException， 以查找系统中是否安装了异常处理程序（VEH、SEH、TopLevelExceptionhandler）。如果安装了就会调用异常处理过程对齐进行处理。 基于SEH的Hook： 有较多限制，基于线程、非全局、基于栈等 基于VEH的Hook: 基于进程、全局，优先于SEH处理。因此VEH+INT3方式进行Hook更具有实用性。 最理想，最有威力的是直接Hook掉ntdll!kiUserExceptionDispatcher，这里是异常处理过程返回用户层处理的第一站，这里Hook比VEH有更早的控制权。 2.4 其他的Hook 修改PE文件的入口点 系统回调机制和分层模式：利用操作系统提供的合法接口,包括： 各类回调机制： 回调函数给了我们对原处理过程进行干预的机会。消息钩子以及内核中的各种回调（进程/线程创建回调、加载映像回调、注册表回调等） 分层服务和过滤驱动模型： 2.5 Hook 时机的选择 Hook时机的选择原则：‘ 尽量选择调用点下游的位置：在满足拦截范围的情况下尽量离调用点进一些 考虑参数处理的难易程度： 通常上层调用接口比较清楚，参数意义明确甚至文档化。 在应用层上对API 进行IAT Hook和Inline Hook足以满足要求 在内核层面，KiFastCallEctry和KeServiceDescriptorTable（SSDT和Shadow SSDT)是两个绝佳的选择。 3、Hook检测技术 3.1 检测技术 不管Address Hook 还是Inline Hook，都是在知道Hook函数位置的前提下检测是否被Hook。 3.1.1 Address Hook 的检测 基本思路： 寻找原始的Address，与当前的Address进行对比 IAT　Hook：　先自行加载待检测的PE模块，然后自行填充IAT，与原模块的IAT进行对比 SSDT　Hook：原始服务表存储在内核映像文件中，可以手动将内核文件加载到内存中，根据当前内核的实际加载位置进行重定位。根据当前实际的SSDT与内核实际加载位置的便宜两，定位到重加在的内核中的相应位置，将两者对比。 对于不容易获取原始地址的Hook：简单的方法是判断Address 是否在这个驱动模块的地址范围之内。 3.1.2 Inline Hook 的检测 基本思路： 自行加载待检测的PE映像，根据时机加载基址重定位 对代码所在的节进行检查比对 3.2 对抗技术 Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-05-02 01:24:14 "},"计算机基础知识/windows系统/注入技术总结.html":{"url":"计算机基础知识/windows系统/注入技术总结.html","title":"注入技术总结","keywords":"","body":"1、注入技术 1.1 静态输入 基本原理：在进程运行之前的适当时机，通过向目标进程的输入表中插入要注入的DLL 路径，当进程被系统loader加载并初始化过程中加载注入的DLL文件的方法。 知识点1： PE文件的加载机制 在新进程执行前，先执行ntdll.dll的LdrInitializeThunk函数； ntdll!LdrInitializeThunk调用LdrInitializeProcess对进程的一些必要内容进行初始化； ntdll!LdrInitializeProcess调用LdrpWalkImportDescriptor对输入表进行处理，加载输入表中的内容并填充应用程序的IAT 实现静态注入有三种方法： 直接修改PE文件的输入表（修改文件）: 通过工具（PE编辑器、十六进程编辑器等）修改PE文件的输入表。前提时对PE文件格式十分了解。 在进程创建时期修改PE输入表（修改内存）：R0/R3都i可以实现，主要思想为：挂起进程、增加信息（增加输入表内容）、恢复进程。 输入表向DLL替换法：DLL劫持技术。根据DLL加载顺序进行文件替换，并在替换后的DLL对原始DLL的导出函数进行转发(即在注入的DLL中要实现原DLL文件的导出函数)，否则会触发异常。 知识点2：DLL的加载顺序 当初始化输入表时，会议递归方式加载输入表中名称指向的DLL文件。系统会在以下位置按顺序进行查找DLL并加载之。 DLL的加载时机和顺序：进程在创建时ntll就已经加载了。ntll时第一个被加载到进程空间的DLL文件。 0、加载DLL时最先在注册表项\\KnownDLLs中查找，若找不到按以下顺序搜索 1、正在加载DLL的进程的可执行文件的目录： 2、系统目录：windows/System32、windows/system、windows/windows 3、正在加载dll的进程的当前目录:（什么时当前目录） 4、PATH环境变量的目录 1.2 动态加载 基本原理：动态加载的原理就是通过一定方法（修改线程EIP、创建新线程、修改进程代码等）修改程序的执行流程， 使其执行LoadLibrary来加载目标DLL文件的过程。 实现方法 CreateRemoteThread: 最经典，在目标进程申请内存空间、放入DLL路径；创建远程线程（回调函数为LoadLibrary, 参数为DLL 路径字符出串地址）。这里为什么会选择LoadLibrary函数作为回调函数，因为他和线程回调函数形式相似。且满足我们需要。 RtlCtreateUserThread法： 和CreateRemoteThread相似， 创建特殊的线程。 QueneUserApc/NtQueneAPCThread APC 注入法： APC异步过程调用，软件中断的机制。当线程从可警醒状态恢复时会检查自己的APC队列。最良好的做法时在驱动中插入APC队列，并修改线程的参数使其满足可警醒来百分百达到APC注入的效果。 SetThreadContext 法： 其原理是挂起线程时系统会保存线程的上下文环境，再次恢复时将之前的环境页恢复并设置EIP为之前保存的值。DLL注入时，在挂起线程后，向线程空间写入shellcode（shellcode中加载DLL），并将线程EIP设置为shellcode的入口点，等执行完shell从的后在跳转回到线程原始状态。 内核中通过HOOk/Notify干预执行流程： 与用于层类似。 内核KeUserModeCallback法： 纯WriteProcessMemory法： 在线程执行预先设置陷阱，在陷阱中完成dll 的加载。时机： 进程创建时注入：ntdll!KiUserApcDispatcher、ntdll!ZwTestAlert、进程入口点 运行中的进程：找调用频率较高的API 1.3 系统机制 基本原理：操作系统某些机制会依赖一些模块，当某些操作触发了这一机制时会主动加载这些模块。通过注册一个符合规范的DLL，将其注册为系统服务模块即可进行DLL注入。 实现方式： SetWindowsHookEx消息钩子注入： Windows消息过滤机制、通过该函数安装一个钩子过滤特定的消息钩子函数。只针对GUI程序。 AppInit_DLL注册表注入：加载user32.dll时会调用LoadAppDLLs()函数，会读取HKLM\\softWare\\Microsoft\\Windows\\NT\\CurrentVersion\\Windows\\AppInit_DLLs， 如果在该注册表项中登记了DLL就会主动加载DLL。只针对GUI程序。 输入法注入: 外挂式和输入法接口IME两种方式。比较流程的是IME实现方式：IME是符合规范的DL， 后缀名为.def文件。其原理是当切换输入法时负责管理输入法的imm32.dll会加载这个IME文件，进而完成输入法注入。 SPI网络过滤注入 ShimEngine注入 Explore Shell 扩展 注入 2、扩展知识 Detours: 微软钩子库，一个Hook Win32 API函数的库 进程的创建过程：Windows PE 加载机制 DLL劫持工具：Aheadlib 会话隔离技术： 系统服务为会话0， 第一个登录的用户为会话1。隔离即指在不同的会话之间进行跨进程创建远程线程会失败。 wow机制： 支持在64位系统上运行32为程序 ARK：反Rootkit工具，简称为ARK（anti-Rootkit）工具。 国内目前最常用的有七个，分别是：IceSword（冰刃）、 Wsyscheck 、Snipesword（狙剑）、SysReveal、XueTr、天琊(Superkill)、Atool 。 简单的应用有：1、删除顽固文件；2、查找隐藏文件和进程；3、结束用任务管理器无法结束的进程。等等。高级应用：1、检测系统中可疑的隐藏进程； 2、进程查杀 ；3、注册表编辑； 4、进程模块卸载； 5、SSDT服务表管理； 6、内核模块察看； 7、Inline Hook扫描； 8、端口管理； ARK工具：　https://www.cnblogs.com/fslnet/articles/2041542.html Detours Github地址： https://github.com/microsoft/Detours Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-05-02 18:37:45 "},"安全工具使用/":{"url":"安全工具使用/","title":"安全工具的使用","keywords":"","body":" 本章内容主要介绍、收集常用的安全工具、框架的使用方法。 主要包括： 1、IDA 的使用 2、OD的在使用 3、xdb的使用 4、windbg 的使用 5、MSF框架的使用 6、CobaltSttrike的使用 Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-05-01 01:23:16 "},"安全工具使用/IDA使用手册.html":{"url":"安全工具使用/IDA使用手册.html","title":"IDA 使用手册","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-05-01 01:22:12 "},"安全工具使用/OD使用手册.html":{"url":"安全工具使用/OD使用手册.html","title":"OD使用手册","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-05-01 01:22:29 "},"安全工具使用/Windbg使用手册.html":{"url":"安全工具使用/Windbg使用手册.html","title":"Windbg 使用手册","keywords":"","body":" windbg 是微软官方提供的一个功能强大的调试器， 可以用于用户态和内核态调试。此外不仅仅用来调试程序， 还可以分析内核、分析崩溃转储文件。在windows平台上有着先天的兼容优势。是安全研究者必须掌握的一个工具。 windbg操作手册： http://windbg.info/doc/1-common-cmds.html 1、Windbg基础使用 1.1 工作空间 工作空间用来描述调试项目的属性、参数设置等信息。windbg程序目录中的theme子目录提供了4中定制的工作空间设置。将每个主题REG文件导入注册表即可应用该主题。 1.2 调试符号 调试符号及其设置参考文章： http://blog.secknow.cn/post/windows_symbols_download.html 1.3 调试过程 调试程序的方式: 以打开方式 附加方式 分析dump文件 调试模式： 远程调试 内核调试： 内核调试模式分为5中，net、USB、1394、COM（这四种为双机调试模式）和本地调试 注意： Windbg调试程序时， 反汇编代码默认停留在ntdll.dll中的系统断点处。不会直接同流在程序入口点，可在命令行窗口输入：“：g@$exentry”转到程序入口处。 2、 windbg 常用命令 2.0 基本命令 查看和加载模块 windbg有三种命令： 以.开始的元命令、基本命令和以！开始的扩展命令。 元命令中常用的： .hh: 查看指定命令的帮助手册 .cls: 清屏 .help: 查看帮助 .reload: 重新加载符号文件 .symfix path: 设置符号文件的下游缓存路径 .sympath path: 设置符号文件的下游缓存路径 .restart: 重新启动调试目标 基本命令： ld: 从符号文件目录或符号服务器中加载符号 lm： 显示已加载模块列表 lmf 显示所有模块及其路径 lmD 显示所有模块详细信息 uf 反汇编某个函数， 比如uf test!main ub 反汇编某地址之前的代码，比如ub 0x 0x410040 L20 扩展命令常用： !analyze -v 详细显示当前异常信息，常用于分析dmp文件 !address 400000 查看指定内存地址的信息 !peb 进程环境块 !teb 线程环境快 !locks 查看进程中有些锁处于锁定状态 !cs -l 查看处于锁定状态的关键区(临界区) !handle 000000c0 f 查看句柄000000c0的信息 其他命令： x [] Mudole!Symbol: 符号检索功能。其中符号名可以用*、？、[]、#、+等特殊字符进行模糊匹配。eg: x nt!memset 查看内核函数memset rM ff: 显示x86架构的所有常用寄存器 单步跟踪 t:F8/F11, 追踪执行，遇到call指令时跟进 p: F10， 单步执行， 遇到call不跟进 g： F5, 运行程序 pa address: 单步到指定地址，不进入call ta address: 进入到指定地址， 进入call pc count: 单步执行到下一个call tc count: 单步执行到下一个call, 并跟进 tb count: 遇到下一个分支指令，遇到call跟进执行， 适用于内核调试 pt: 单步执行到吓一跳call返回指令 tt: 单步执行到吓一跳call返回指令， 遇到call跟进 ph: 单步到下一条分支指令 th: 单步到下一条分支指令，遇到call跟进 wt: 自动追踪函数执行过程 2.1 断点命令 软件断点： 用于设置软件断点INT3 bp：设置和地址关联的断点。 bp[ID] [options] [Address[Passes]] [\"commandstring\"] ID：指定断点ID,可缺省，用于模式不限个数， 内核调试限制32个断点 Options:可缺省。/1(中断后自动删除该断点)、/c(指定最大的调用深度)、/C(指定最小的调用深度) Address: 地址或符号 Passes: 忽略中端次数，可缺省 CommandString: 用与指定一组命令，当中断时会自动执行这组命令。用双引号包围。 bu: 设置和符号相关的断点， 符号一旦失效断点页会失效。 eg： bu kernel32!GetVersion bu设置的断点在工作空间中， 下次启动windbg时会自动设置该断点 bm: 设置含通配符的断点。可以一次创建一个或者多个bu/bp断点。 eg:bm msvcr80d!print* //对模块msvcr80d中以print开头的所有函数设置断点 硬件断点 硬件断点可以实现一些软件断点无法实现的功能，如监视I/O访问等。 ba[ID] Access Size [Options] [Address [passes]] [\"commandstring\"] ID：指定断点ID,可缺省 Access: 指定断点触发的访问方式：e在读取或执行时中断、r在读取时中断、w在写入数据时中断、i在执行输入/输出访问I/O时触发断点。 Size: 访问长度, x86中用1、2、4分别代表1字节、2字节、3字节， x64中多了一个8， 代表4字节 Address: 断点地址，按四则的值进行对齐 Passes: 忽略中端次数，可缺省 CommandString: 用与指定一组命令，当中断时会自动执行这组命令。用双引号包围。 条件断点 软件断点和硬件断点都支持条件断点，当断点被触发后，windbg会执行一些自定义的判断并执行。 bp|bu|bm|ba _address \"j (condiction) 'OPtionalCommands'; 'gc'\" bp|bu|bm|ba _address \".if(condiction){OPtionalCommands}.else {gc}\" windbgz支持更为复杂的条件断点表达式，善用条件断点可以减少不必要的中断，以提高效率。 管理断点 bl: 列出当前断点。 bc: 删除断点 //bc * 删除所有断点 bd: 禁止断点 //bd 1-3, 4 禁止1234号断点 be: 启用断点 2.2 调用栈命令 栈是进行函数调用的基础，因此观察和分析栈式最重要的调试手段。 k: 基本的查看调用栈 kb: 只用于显放在栈上的前三个参数 kp: 把参数和参数值以函数原型的形式显示出来,包括参数类型、名字、取值（前提时福海完整） kv: 在kb命令基础上增加帧指针省略信息和调用约定的显示 kd：用于列出栈中的数据 2.3 内存相关命令 查看内存：d[类型] [地址范围] 类型： da: db: 字节和ASCII字符串 dc: DWORD和ASCII字符串 dd: 4字节DWORD格式 dD: df: 4字节单精度浮点数格式 dp: dq: 8字节格式 du: Unicode字符串 dw: 双字节WORD格式C dW: 双字节和ASCII字符串 dyb: 显示二进制和字节 dyd: 显示二进制和DWROD值 ds: dS: 显示地址及相关符号 地址范围： 用L+数字标识 dw 4012465 L5: 标识以DWORD格式显示地址 4012465处的前四个数据 搜索内存 s - [类型] range patten 类型：标识搜索的数据类型。 b: BHYTE、w:WORD、d:DWORD、a:ASCII、u:Unicode,默认类型b range：表示地址范围。用起始地址 + 终止地址； 或起始地址 + L(长度表示)，若超过256MB, 用L?length patten: 指定要搜索的内容 s -a 0x00000000 L?0x7fffffff myest: 表示在目标地址为2GB的用户内存空间中搜索ASCII字符串mytest 修改内存 e {a|u|za|zu} address \"string\" a: 以0结尾的ASCII字符串 u: 以0结尾的Unicode字符串 za: 不以0结尾的ASCII字符串 zu: 不以0结尾的Unicode字符串 e {a|b|d|D|f|q|u|w} address [values] //a|b|d|D|f|q|u|w表示类型 观察内存属性C !adress [内存地址] 2.4 进程线程关命令 栈是进行函数调用的基础，因此观察和分析栈式最重要的调试手段 ~*命令显示当前所有线程的详细信息 ~* kv可以打印所有线程堆栈。 [~1s] 切换到1号线程，然后可以使用kv查看1号线程的调用栈 !runaway 显示所有线程的CPU消耗 .process 命令指定要用作进程上下文的进程 !process 0 0 获取用户空间的所有的进程的信息 .process /r /p 你需要断的应用程序的EProcess地址 通过/r /p来切换进程上下文 |. 显示当前调试进程 |* 显示当前调试中的所有进程 3、windbg高级用法 3.1 远程调试 3.2 内核调试 3.3 脚本 Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-05-02 18:34:16 "},"安全工具使用/GDB使用手册.html":{"url":"安全工具使用/GDB使用手册.html","title":"GDB 使用手册","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-05-01 01:22:38 "},"安卓逆向课程/总述.html":{"url":"安卓逆向课程/总述.html","title":"安卓逆向","keywords":"","body":"安卓逆向的学习主要包含流量分析和源码分析两部分内容： 流量分析：主要从流量层面以定位关键代码或者API接口为主要目标 源码分析：用源代码层面出发，找到API调用接口中涉及的相关算法的具体实现，破解算法从而构造参数 爬虫：拿到API接口和接口参数后，通过爬虫的方式来批量获取数据 1、抓包和流量分析 以流量为核心，定位关键API信息。涉及内容包括但不限于应用层抓包、HOOK、路由器抓包等知识 抓包环境的搭建、抓包工具的使用 抓包对抗：SSL、双向认证、代码混淆、加壳等手段 2、安卓源码编译 学习安卓源码的主要目的在于理解APP加载运行机制，通过定制化的改造、编译源码来实现脱壳或者从系统层面来捕获应用的流量。 安卓源码编译 定制脱壳机 3、批量数据获取 批量获取数据主要在于有了接口和接口参数后，通过自动化的方式来获取批量数据。 Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:23:51 "},"安卓逆向课程/流量分析/抓包与流量分析.html":{"url":"安卓逆向课程/流量分析/抓包与流量分析.html","title":"抓包与流量分析","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:26:52 "},"安卓逆向课程/流量分析/抓包环境的搭建.html":{"url":"安卓逆向课程/流量分析/抓包环境的搭建.html","title":"抓包环境的搭建","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:53:49 "},"安卓逆向课程/流量分析/抓包原理刨析.html":{"url":"安卓逆向课程/流量分析/抓包原理刨析.html","title":"抓包原理刨析","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:54:00 "},"安卓逆向课程/安卓源码/安卓源码编译.html":{"url":"安卓逆向课程/安卓源码/安卓源码编译.html","title":"安卓源码编译","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:27:10 "},"安卓逆向课程/安卓源码/安卓源码分析.html":{"url":"安卓逆向课程/安卓源码/安卓源码分析.html","title":"安卓源码分析","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 14:01:05 "},"安卓逆向课程/安卓源码/编译环境搭建.html":{"url":"安卓逆向课程/安卓源码/编译环境搭建.html","title":"源码编译环境的搭建","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 21:37:00 "},"恶意样本分析/总述.html":{"url":"恶意样本分析/总述.html","title":"恶意样本分析","keywords":"","body":"恶意样本的分析，主要目的在于通过对样本分析的学习，能掌握恶意软件分析能力，另一方面通过恶意样本的行为和功能等多方面来加深对操作系统的理解。 恶意样本分析的主要工作包括： 常见的恶意样本和分类、常见样本的功能 样本来源：样本从哪里来 样本怎么分类：ClamAV、YARA工具的使用 主要关注的恶意软件类型： 勒索软件 如何实现免杀 样本分析工具和分析环境： 分析工具：静态分析工具、动态分析工具 沙箱：开源沙箱、windows自带沙箱的原理 恶意样本分析的方法 静态分析 动态分析 样本分析基础 Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:41:58 "},"恶意样本分析/分析环境的搭建.html":{"url":"恶意样本分析/分析环境的搭建.html","title":"样本分析环境","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:40:49 "},"恶意样本分析/静态分析/静态分析概述.html":{"url":"恶意样本分析/静态分析/静态分析概述.html","title":"样本之静态分析","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:44:46 "},"恶意样本分析/动态分析/动态分析概述.html":{"url":"恶意样本分析/动态分析/动态分析概述.html","title":"样本之动态分析","keywords":"","body":"Copyright © blackwin 2000-2020 all right reserved，powered by Gitbook文件修订时间： 2021-04-11 13:44:18 "}}