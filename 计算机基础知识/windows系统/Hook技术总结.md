



# 1、Hook 的概述

Q: 什么是Hook？

A: 简单来说就是通过一定的手段埋下钩子,钩住我们关心的重要流程, 然后根据需要对执行过程进行干预。



Q: Hook用途是干什么？

A: 实现二次开发、补丁、信息截获、安全防护



Q: Hook技术的要点是什么？

A: 对于Hook来说如何选择Hook点事一个很重要的Point。



Q: x64平台Hook需要注意什么？

A:  基本方法与x86平台一致， 此外需要考虑： 指针的定义长度和操作问题、内存地址对齐问题、PE格式问题（某些结构体字段的差异等）、调用约定的变化（在x64中只有一种调用约定__fastcall）、指令跳转问题、PatchGuard问题（x64系统基本都开启了该功能，以确保内核的核心模块和重要数据结构不被随意修改，一旦被修改会产生CRITICAL_STRUCTURE_CORRUPTION的蓝屏错误）。



# 2、各种Hook的原理及其实现



##  2.1 Address Hook



**基本原理**

> 通过修改数据，通常是函数地址进行Hook。这些地址一般存放在各类表中、数据结构中、指定的地址、或者寄存器中。这些数据有一些特征：在某个时候通过影响EIP从而控制程序的流程。因此只要将改地址替换成Detours函数的地址就可以拿到程序的控制权了。



**实现步骤**

```C
1、定义一个Detours函数：调用约定、参数、返回值员被Hook函数保持一致
 
2、定义一个与被Hook 函数原型一致的函数指针， 指向原始函数
    
3、遍历查表或遍历匹配替换原地址，关闭写保护以及写入Detours函数地址。 
```



### 2.1.1  PE IAT 表

IAT(输入地址表)：在PE结构中，有一组数据结构，分别对应于被输入的DLL，每一个这样的结构都给出了被输入DLL的名称， 并指向一组函数指针， 称为导入地址表IAT， 其包含了每一个DLL中的函数地址。

**特点： 只针对某个模块起作用。**



### 2.1.2 PE的 EAT表

基本原理：PE文件的如数地址表（EAT）中存放的是函数地址的偏移，使用是需要加上模块基址。通过EAT Hook影响的是PE文件运行起来之后需要动态加载导入的函数（IAT Hook只能影响PE初始化时导入的函数， 不能影响通过LoadLibrary、GetProAddress调用的函数）。



### 2.1.3 user32.dll的回调函数表

基本原理：在user32.dll 中有一个名为USER32!apfnDispatch 的回调函数表，其中存放各种利用GUI的回调函数，通常与内核函数KeUserModeCallback函数配合使用。



### 2.1.4 IDT表

基本原理：IDT表（系统中断描述符表）中保存了系统中断对应的处理函数（包括调试中断、键盘、鼠标中断、系统调用中断等）。**IDT表基址存放在idtr中，表内的项目数存放在idtl寄存器中。**每个中断项的中断处理例程称为ISR。





### 2.1.5 SSDT表

windows应用程序调用API 后转入操作系统内核进行处理时首先用到SSDT表，是将R3的函数接口和R0的函数联系起来的一个映射表。

- SSDT表：主要是处理来自 Ring3 层得 Kernel32.dll 中的系统调用。结构为KeServiceDescriptorTable， 在ntoskrnl.exe(Windows 操作系统内核文件，包括内核和执行体）是导出的，声明后直接使用。 
- Shadow SSDT 表：用于处理各种GUI服务的表，结构为KeServiceDescriptorTableShadow。为生命，通过其他方式访问。主要处理来自 User32.dll 和 GDI32.dll 中的系统调用。

![image-20210501232805288](https://gitee.com/blackwin/blogimg/raw/master/image/image-20210501232805288.png)

### 2.1.6 C++类的虚函数表

基本原理： 函数重载和虚函数是C++很重要的一个功能，可以使子类以相同的接口实现与积累不同的功能。编译器试下这一功能时使用了虚函数表来保存虚函数的地址。默认情况下改地址保存了积累的虚函数地址，一旦子类冲在了某个函数，编译器就会用子类该函数地址替换虚函数表中对应的函数地址（在编译后虚函数表就是一个固定的表了）。可以通过修改虚函数地址表来进行Hook。



### 2.1.7 COM接口的功能函数

基本原理：COM 接口的所有接口函数都放在一个表中，与C++虚函数表一样。



## 2.2 Inline Hook

Inline Hook是直接修改指令的Hook。一般使用：jmp、call、retn之类的转移指令。有以下五种模式。



### 2.2.1  jmp xxxxx(5字节)

直接跳转到某个地址。



### 2.2.2 push xxxxxx(6字节)

通过压栈返回实现跳转



### 2.2.3  mov eax, xxxxxxx/jmp eax (7字节)

先将转移地址放到寄存器中，再实现跳转。 EAX一般存放函数返回值，在函数入口修改不会影响函数的执行结果。



### 2.2.4 call Hook

修改call地址的Hook：直接将跳转地址改掉

替换Thunk方式的IAT Hook： 只修改函数偏移



### 2.2.5 HotPatch Hook

一个短调加一个长跳。

windows  API开头指令两种形式:  有SEH、无SEH

每个函数的第一条指令一定为2字节，而且从函数位置往上一般是5个Nop或者一个INT3



## 2.3 基于异常的Hook

基本原理：当程序执行过程中发生异常时，系统内核的异常处理过程nt!kiDispatchexception会开始工作；在没有内核调试器存在且异常程序没被调试的情况下。系统会把异常处理过程转交给用户态的异常处理过程ntdll!RtDispatchException， 以查找系统中是否安装了异常处理程序（VEH、SEH、TopLevelExceptionhandler）。如果安装了就会调用异常处理过程对齐进行处理。

- 基于SEH的Hook： 有较多限制，基于线程、非全局、基于栈等
- 基于VEH的Hook: 基于进程、全局，优先于SEH处理。因此VEH+INT3方式进行Hook更具有实用性。
- 最理想，最有威力的是直接Hook掉ntdll!kiUserExceptionDispatcher，这里是异常处理过程返回用户层处理的第一站，这里Hook比VEH有更早的控制权。



## 2.4 其他的Hook

* 修改PE文件的入口点
* 系统回调机制和分层模式：利用操作系统提供的合法接口,包括：
  * 各类回调机制： 回调函数给了我们对原处理过程进行干预的机会。消息钩子以及内核中的各种回调（进程/线程创建回调、加载映像回调、注册表回调等）
  * 分层服务和过滤驱动模型：

## 2.5 Hook 时机的选择



Hook时机的选择原则：‘

* 尽量选择调用点下游的位置：在满足拦截范围的情况下尽量离调用点进一些
* 考虑参数处理的难易程度： 通常上层调用接口比较清楚，参数意义明确甚至文档化。
* 在应用层上对API 进行IAT Hook和Inline Hook足以满足要求
* 在内核层面，KiFastCallEctry和KeServiceDescriptorTable（SSDT和Shadow SSDT)是两个绝佳的选择。



# 3、Hook检测技术

## 3.1 检测技术

不管Address Hook 还是Inline Hook，都是在知道Hook函数位置的前提下检测是否被Hook。

### 3.1.1 Address Hook 的检测

**基本思路： 寻找原始的Address，与当前的Address进行对比**



- IAT　Hook：　先自行加载待检测的PE模块，然后自行填充IAT，与原模块的IAT进行对比
- SSDT　Hook：原始服务表存储在内核映像文件中，可以手动将内核文件加载到内存中，根据当前内核的实际加载位置进行重定位。根据当前实际的SSDT与内核实际加载位置的便宜两，定位到重加在的内核中的相应位置，将两者对比。
- 对于不容易获取原始地址的Hook：简单的方法是判断Address 是否在这个驱动模块的地址范围之内。



### 3.1.2 Inline Hook 的检测

基本思路：

* 自行加载待检测的PE映像，根据时机加载基址重定位
* 对代码所在的节进行检查比对

## 3.2 对抗技术

